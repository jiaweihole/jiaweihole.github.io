<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学习Unity笔记：生命周期函数</title>
      <link href="2020/10/22/%E5%AD%A6%E4%B9%A0Unity%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
      <url>2020/10/22/%E5%AD%A6%E4%B9%A0Unity%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="学习Unity笔记：生命周期函数"><a href="#学习Unity笔记：生命周期函数" class="headerlink" title="学习Unity笔记：生命周期函数"></a>学习Unity笔记：生命周期函数</h1><ol><li><p>生命周期函数又称：必然事件、message</p></li><li><p>生命周期函数中的各种方法不用就删掉<br>因为会持续调用 update（）等有循环的空函数而浪费资源。</p></li><li><p>unity可更改脚本模板 不必每次都去删除Start（）、Update（） 方法在百度。</p></li><li><p>生命周期函数中的各种方法均是private</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]<span class="comment">//(使private的字段可显示在unity中进行设置)</span></span><br><span class="line"><span class="comment">//序列化字段: 作用 在编辑器中显示私有变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>,a=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作用：在编译器中隐藏字段</span></span><br><span class="line">[<span class="meta">HidelnInspector</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> b；</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性：在编译器中不能显示、通常脚本中不写</span></span><br><span class="line"><span class="comment">//不要在脚本中写构造函数</span></span><br><span class="line"><span class="comment">//不能在子线程中访问主线程成员如让：当前 b=Time.time；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行时机：创建游戏对象-&gt;立即执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> Awake（）</span><br><span class="line">Debug.Log（<span class="string">&quot;Awake--&quot;</span>+Time.time+<span class="string">&quot;-&quot;</span>+<span class="keyword">this</span>.name）；</span><br><span class="line"><span class="comment">//执行时机：创建游戏对象--&gt;脚本启用-&gt;才执行0个引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> Start（）</span><br><span class="line">Debug.Log（<span class="string">&quot;Start--&quot;</span>+Time.time +<span class="string">&quot;-&quot;</span>+<span class="keyword">this</span>.name）；</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************物理阶段*********************/</span></span><br><span class="line">执行时机：每隔固定时间执行<span class="number">1</span>次。（时间可以修改）</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> FixedUpdate（）</span><br><span class="line">Debug.Log（Time.time）；</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 物理阶段</span></span><br><span class="line"><span class="comment">·FixedUpdate 固定更新：</span></span><br><span class="line"><span class="comment">脚本启用后，固定时间被调用，适用于对游戏对象做物理操作，例如移动等。</span></span><br><span class="line"><span class="comment">设置更新频率：&quot;Edit&quot;--&gt;&quot;Project Setting&quot;--</span></span><br><span class="line"><span class="comment">&gt;&quot;Time&quot;--&gt;&quot;Fixed Timestep&quot;值，默认为0.02s.</span></span><br><span class="line"><span class="comment">·OnCollisionXXX碰撞：</span></span><br><span class="line"><span class="comment">当满足碰撞条件时调用。</span></span><br><span class="line"><span class="comment">·OnTriggerXXX触发：</span></span><br><span class="line"><span class="comment">当满足触发条件时调用。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行时机：渲染帧执行，执行间隔不固定//适用性：处理游戏逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> Update（）</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>) <span class="comment">//延迟更新：</span></span></span><br><span class="line"><span class="function"><span class="comment">//在Update函数被调用后执行，适用于跟随逻辑。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//之后的阶段</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 输入事件</span></span></span><br><span class="line"><span class="function"><span class="comment">·OnMouseEnter 鼠标移入：鼠标移入到当前 Collider时调用。</span></span></span><br><span class="line"><span class="function"><span class="comment">·OnMouseOver鼠标经过：</span></span></span><br><span class="line"><span class="function"><span class="comment">鼠标经过当前 Collider时调用。</span></span></span><br><span class="line"><span class="function"><span class="comment">OnMouseExit 鼠标离开：</span></span></span><br><span class="line"><span class="function"><span class="comment">鼠标离开当前 Collider 时调用。</span></span></span><br><span class="line"><span class="function"><span class="comment">OnMouseDown 鼠标按下：鼠标按下当前Collider时调用。</span></span></span><br><span class="line"><span class="function"><span class="comment">·OnMouseUp 鼠标抬起：</span></span></span><br><span class="line"><span class="function"><span class="comment">鼠标在当前Collider 上抬起时调用。</span></span></span><br><span class="line"><span class="function"><span class="comment">·On BecameVisible 当可见：</span></span></span><br><span class="line"><span class="function"><span class="comment">当Mesh Renderer 在任何相机上可见时调用。</span></span></span><br><span class="line"><span class="function"><span class="comment">·OnBecamelnvisible 当不可见：</span></span></span><br><span class="line"><span class="function"><span class="comment">当Mesh Renderer 在任何相机上都不可见时调用。</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">·OnDisable当不可用：</span></span></span><br><span class="line"><span class="function"><span class="comment">对象变为不可用或附属游戏对象非激活状态时此函数被调用。</span></span></span><br><span class="line"><span class="function"><span class="comment">·OnPestroy当销毁：</span></span></span><br><span class="line"><span class="function"><span class="comment">当脚本销毁或附属的游戏对象被销毁时被调用。</span></span></span><br><span class="line"><span class="function"><span class="comment">·OnApplicationQuit 当程序结束：</span></span></span><br><span class="line"><span class="function"><span class="comment">应用程序退出时被调用。 */</span></span></span><br></pre></td></tr></table></figure><p>描述的过乱但是是顺着关键词记录的具体函数执行流程还得看下图（此为Unity 脚本参考中图片的中文翻译版）</p><p><img data-src="https://i.loli.net/2020/10/22/v52b4zA1ZGFWMHo.jpg" alt="Unity生命周期函数执行流程"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
